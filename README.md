# Avito Moderation System

Небольшой прототип системы модерации объявлений: список объявлений с фильтрами и деталями, простая статистика по выборке и экспорт отчёта.  
Проект сделан как SPA на React с использованием мок-API предоставленного Node.js сервера и полностью поднимается через Docker Compose.

---

## Описание проекта

Основная идея — показать, как может выглядеть рабочее место модератора.  
Интерфейс состоит из трёх основных страниц (роутов):

### `/list` — список объявлений
- загрузка объявлений с сервера;
- пагинация;
- фильтры (статус, категория, цена, строка поиска);
- отображение ключевых полей объявления: фото, заголовок, цена, продавец, статус;
- переход в карточку объявления.

### `/item/:id` — карточка объявления
- загрузка всех данных по конкретному объявлению;
- полноценное отображение деталей: изображения, характеристики, описание;
- история модерации (если есть);
- UI-шаблон под модераторские действия (одобрение/отклонение/комментарии).

### `/stats` — статистика
- количественные показатели по выборке: всего, одобрено/отклонено, распределения;
- расчёт статистики через чистые функции;
- экспорт отчёта в **CSV** и **PDF**.

---

## Запуск проекта (Docker Compose)


### Требования

- Docker
- Docker Compose

### Команды

```bash
git clone https://github.com/wraithfel/avito-moderation.git
cd avito-moderation

docker compose up --build
````

После сборки и запуска:

* API доступен по адресу: `http://localhost:3001`
* клиент доступен по адресу: `http://localhost:8080`

Остановить сервисы:

```bash
docker compose down
```

---

## Пояснения по стеку

### Фронтенд

**TypeScript** — обеспечивает типобезопасность и удобную поддержку в IDE, что делает работу с данными и компонентами надёжной и предсказуемой.

**Vite** — предоставляет очень быстрый dev-сервер и простую сборку «из коробки», позволяя комфортно разрабатывать SPA без сложной конфигурации, удобно проксировать, настройка Webpack была бы дольше.

**Axios** — служит удобным абстрактным слоем над HTTP-запросами, обеспечивает единый базовый URL, интерсепторы, обработку ошибок и корректную сериализацию параметров, что делает работу с API чище и структурнее, гораздо удобнее работать, чем с классическим fetch.

**@tanstack/react-query** — серверный стейт-менеджер, который отвечает за получение и кеширование данных с сервера, автоматически обновляет закешированные данные при необходимости и предоставляет явные состояния загрузки, ошибки и успешного получения данных.

**MUI** — предлагает набор готовых адаптивных UI-компонентов, что позволяет сосредоточиться на логике приложения и не тратить время на разработку базовых элементов интерфейса.

**SCSS-модули** — дают возможность писать изолированные стили для каждого компонента и избегать конфликтов глобальных CSS-классов, упрощая сопровождение проекта.

**Vitest + @testing-library/react** — обеспечивают быстрые юнит-тесты и тестирование поведения компонентов, позволяя проверять пользовательские сценарии без привязки к внутренним деталям реализации.


### Полный стек
* TypeScript
* React
* React Router
* Vite
* Axios
* @tanstack/react-query
* MUI (Material UI)
* SCSS-modules
* Feature-Sliced Design (FSD) структура
* Manrope (кастомный шрифт через @font-face)
* Vitest
* @testing-library/react
* ESLint (flat config)
* Prettier
---

## Архитектура фронта (FSD)

Фронтенд организован по **Feature-Sliced Design**:

```text
└── client/                     # React-приложение (FSD)
    ├── Dockerfile
    ├── nginx.conf
    ├── index.html
    ├── vite.config.ts
    ├── tsconfig.json
    ├── package.json
    └── src/
        ├── app/                # инициализация приложения
        │   ├── fonts/          # шрифты (Manrope .ttf)
        │   ├── providers/      # Router, QueryClient и т.п.
        │   ├── routes/         # конфиг маршрутов
        │   └── styles/         # глобальные стили, reset
        ├── pages/              # страницы (уровень маршрутов)
        ├── widgets/            # крупные композиции
        ├── features/           # функциональные фичи
        ├── entities/           # сущности предметной области
        └── shared/             # утилиты, ui-компоненты, не знающие о бизнес-логике

```

## Почему FSD и чем он лучше других подходов

Для фронтенда я использовал **Feature-Sliced Design (FSD)**, потому что он хорошо подходит для приложений, которые могут расширяться: добавляться новые страницы, фичи, роли пользователей, типы статистики и т.д. Даже в небольшом проекте такая структура сразу задаёт правильный каркас для масштабирования.

### Основные плюсы FSD

**Фичи — основная единица декомпозиции.**  
Вместо того чтобы разбрасывать логику по `components/`, `utils/` и `hooks/`, каждая функциональность живёт в своей собственной feature (например, фильтры, экспорт статистики). Это делает навигацию по коду очевидной и уменьшает связанность.

**Чёткое разделение слоёв.**  
Уровни `app → pages → widgets → features → entities → shared` дают понятную границу ответственности: где страничная логика, где композиция UI, где бизнес-логика фич, где сущности, а где общие утилиты.

**Локализация изменений.**  
Фича изменяется — меняются только её файлы. Например, логика фильтров лежит в `features/ad-filters` вместе с тестами и не дублируется по всему проекту.

**Хорошая масштабируемость.**  
Если добавить новые сущности (пользователь, жалоба), новые страницы или новые виды статистики, структура не «ломается» — модули естественно раскладываются по слоям.

**Лучше, чем плоская структура по типам файлов.**  
Папки вроде `components/` быстро превращаются в свалку несвязанных артефактов. В FSD бизнес-логика фич и их UI-части разделены: логика фильтров — в feature, UI списка — в widget, страница — в pages.

**Предсказуемые зависимости.**  
Импорт идёт только «вверх»:  
`shared → entities → features → widgets → pages → app`.  
Это снижает риск циклических зависимостей и скрытых связей.

**Проще тестировать.**  
У каждой фичи есть свой собственный набор утилит и преобразователей — их легко тестировать изолированно, без поднятия всего приложения.

---

## Что реализовано

### 1. Главная страница — Список объявлений (/list)

**Карточки объявлений:**
- изображение товара (с placeholder’ом);
- название объявления;
- цена;
- категория;
- дата создания;
- статус (на модерации / одобрено / отклонено);
- индикатор приоритета (обычный / срочный).

**Фильтры и поиск:**
- фильтр по статусу (множественный выбор);
- фильтр по категории;
- фильтр по диапазону цен;
- поиск по названию объявления;
- сброс всех фильтров.

**Сортировка:**
- по дате создания (новые / старые);
- по цене (возрастание / убывание);
- по приоритету.

**Пагинация:**
- по 10 объявлений на страницу;
- навигация между страницами;
- отображение общего количества объявлений.

**Дополнительно реализовано:**
- синхронизация фильтров с URL (можно скопировать ссылку и открыть тот же набор фильтров);
- сохранение состояния сортировки и страницы при навигации.

---

### 2. Страница детального просмотра объявления (/item/:id)

**Информация об объявлении:**
- галерея изображений (минимум 3 — placeholder);
- полное описание;
- таблица характеристик (ключ–значение).

**Информация о продавце:**
- имя;
- рейтинг;
- количество объявлений;
- дата регистрации.

**История модерации:**
- список всех действий с объявлением;
- имя модератора;
- дата и время решения;
- принятое решение;
- комментарий (если есть).

**Панель действий модератора:**
- кнопка «Одобрить»;
- «Отклонить»;
- «Вернуть на доработку»;
- обязательное указание причины при отклонении;
- быстрые шаблоны причин («Запрещённый товар», «Неверная категория», «Мошенничество» и т.д.);
- поле для произвольного комментария.

**Навигация:**
- кнопка «Назад»;
- кнопки «Предыдущее» / «Следующее» объявление.

---

### 3. Страница статистики модератора (/stats)

**Общая статистика:**
- количество проверенных объявлений;
- процент одобренных;
- процент отклонённых;
- метрика по категориям и статусам.

**Фильтр по периоду:**
- сегодня;
- последние 7 дней;
- последние 30 дней.

**Экспорт данных:**
- экспорт в CSV;
- экспорт в PDF.

---

### 4. Дополнительная функциональность

**Горячие клавиши:**
- `A` — одобрить;
- `D` — отклонить;
- стрелки ← / → — навигация;
- `/` — фокус на поиск.

**Bulk-операции:**
- выбор нескольких объявлений;
- массовое одобрение / отклонение;
- счётчик выбранных элементов.

**Анимации:**
- плавные переходы;
- анимация появления карточек;
- skeleton-состояния.

**Темная тема:**
- переключатель темы;
- сохранение выбора в localStorage.

---

### Что не реализовано

- "Real-time" обновления списка объявлений и счетчик новых.

Остальные пункты требований + допы — полностью реализованы.

---

## Компромисс: Почему не используется глобальное хранилище (Redux / MobX), а выбран TanStack Query

В проекте нет необходимости в классическом глобальном сторе, потому что:

**1. Большая часть данных — серверные, не клиентские.**  
Списки объявлений, фильтрованные выборки, статистика — всё это «серверные данные», а не локальное состояние UI.  
TanStack Query идеально подходит для их управления.

**2. React Query сам решает:**
- кеширование;
- фоновые обновления;
- дедупликацию запросов;
- обработку ошибок;
- повторные запросы;
- синхронизацию с URL.

Это снимает огромный пласт ручной логики, который в Redux пришлось бы писать вручную.

**3. UI-состояние и так компактно живёт локально.**  
Светлая/тёмная тема, открытые модалки, выбор карточек — это маленькие локальные состояния, не нуждающиеся в глобальном сторе.

**4. Меньше бойлерплейта и выше скорость разработки.**

**5. Архитектура FSD + Query даёт ясное разграничение:**
- бизнес-логика фич — в `features`;
- работа с API — в `shared/api`;
- кеширование — в react-query;
- UI — в widgets/pages.

В результате код чище, меньше связей, проще развивать.

---

## Оптимизации, которые уже реализованы

- **Серверные данные кешируются** — при переключении страниц/фильтров не делаются лишние запросы.
- **URL-синхронизация фильтров** — фильтры восстанавливаются при обновлении страницы.
- **Разделение логики фильтров в чистые функции** — легко тестируется и снижает связность.
- **Маппинг данных с API вынесен в entities** — UI не зависит от сырого формата сервера.
- **SCSS-модули** — изолированные стили и минимальная нагрузка по CSS.
- **Фичи изолированы (FSD)** — изменения в одной зоне не ломают другие.

---


## Что можно улучшить/ретро

### 1. Усиление переиспользования UI-элементов
- Выделить повторяющиеся элементы интерфейса в папку `shared/ui`  
  (кнопки, карточки, таблицы, layout-компоненты, элементы фильтров).
- Создать единый UI-кит поверх MUI с типизированными обёртками, чтобы исключить дублирование пропсов и стилей.
- Уменьшить дублирование логики отображения списков и карточек в widgets.

---

### 2. Глубокая декомпозиция widgets
- Разбить крупные виджеты (`AdsListWidget`, `StatsWidget`) на более мелкие модули.  
- Логику пагинации, сортировки, отображения пустого состояния и ошибок выделить в отдельные фичи.
- Места, где пересекаются фичи, сделать композициями мини-виджетов.
---

### 3. Расширение тестового покрытия
- Добавить больше unit-тестов для критичных зон:  
- Покрыть тестами UI-компоненты с важной логикой (интерактив фильтров, состояния загрузки).
---

### 4. Добавление E2E-тестирования критичных сценариев
---

### 5. Оптимизация загрузки (code splitting) для улучшения Core Web Vitals
- Разделить код по маршрутам (ленивая загрузка `React.lazy + Suspense`).
- Грузить тяжёлые компоненты статистики или экспорта только при необходимости.
- Вынести графики и PDF-генерацию в отдельные чанки.
---

### 6. Улучшение наблюдаемости и качества работы
- Добавить клиентское логирование и обработку ошибок (например, через Sentry).
- Ввести централизованную обработку ошибок API.
- Разные Error Boundary для разных ошибок - сейчас один для любого падения
